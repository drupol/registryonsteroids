<?php

/**
 * @file
 * Main module file.
 */

use Drupal\registryonsteroids\FunctionGroupUtil;
use Drupal\registryonsteroids\ThemeHookStubFactory;

global $conf;

// Auto-rebuild the theme registry.
if (variable_get('registryonsteroids_rebuild_registry', FALSE) && !defined('MAINTENANCE_MODE')) {
  // Rebuild .info data.
  system_rebuild_theme_data();
  // Rebuild theme registry.
  drupal_theme_rebuild();
}

$conf['theme_debug'] = variable_get('registryonsteroids_theme_debug', FALSE);

/**
 * Implements hook_menu().
 *
 * @return array[]
 */
function registryonsteroids_menu() {
  return array(
    'admin/config/development/registryonsteroids' => array(
      'title' => 'Registry On Steroïds',
      'description' => 'Registry On Steroïds configuration',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('_registryonsteroids_admin_settings'),
      'access arguments' => array(
        'administer site',
      ),
      'file' => 'registryonsteroids.admin.inc',
    ),
  );
}

/**
 * Implements hook_module_implements_alter().
 *
 * @param mixed[] $implementations
 *   Format: $[$module] = $group
 * @param string $hook
 */
function registryonsteroids_module_implements_alter(array &$implementations, $hook) {
  if ('theme_registry_alter' === $hook) {
    /* @see _registryonsteroids_first_theme_registry_alter() */
    $implementations = array('_registryonsteroids_first' => FALSE) + $implementations;

    /* @see _registryonsteroids_last_theme_registry_alter() */
    $implementations['_registryonsteroids_last'] = FALSE;
  }
}

/**
 * Callback for hook_theme_registry_alter().
 *
 * Registered to run before all other implemntations.
 *
 * @param array[] $registry
 *   Format: $[$theme_hook] = $info
 */
function _registryonsteroids_first_theme_registry_alter(array &$registry) {
  // Figure out which theme this applies to.
  if (PHP_VERSION_ID >= 50400) {
    $trace = debug_backtrace(0, 3);
  }
  else {
    // Second parameter not supported in PHP < 5.4.0. It would cause a
    // "Warning: debug_backtrace() expects at most 1 parameter, 2 given".
    $trace = debug_backtrace(0);
  }
  if (!isset($trace[2]['function'], $trace[2]['args'][0])
    || '_theme_build_registry' !== $trace[2]['function']) {
    watchdog(
      'registryonsteroids',
      'hook_theme_registry_alter() was called from an unexpected place. We cannot determine which theme this registry belongs to. registryonsteroids functionality might not work.',
      [],
      WATCHDOG_WARNING
    );

    return;
  }

  /* @see _theme_build_registry() */
  list($theme, $base_themes) = $trace[2]['args'];

  // Include all files registered as 'include' for theme hooks, so that
  // get_defined_functions() finds all preprocess functions.
  $include_files_map = array();
  foreach ($registry as $info) {
    if (isset($info['includes'])) {
      foreach ($info['includes'] as $include_file) {
        $include_files_map[$include_file] = $include_file;
      }
    }
  }

  foreach ($include_files_map as $include_file) {
    include_once DRUPAL_ROOT . '/' . $include_file;
  }

  $user_functions = get_defined_functions()['user'];

  /**
   * @var string[][] $prefixes_by_type
   *   Format: $[$prefix_type][$prefix] = $prefix
   */
  $prefixes_by_type = _registryonsteroids_theme_make_prefixes($base_themes, $theme);

  /**
   * @var string[] $prefixes
   *   Format: $[$prefix] = $prefix
   */
  $prefixes = array_merge(...array_values($prefixes_by_type));

  // Apply Registry On Steroids sauce.
  _registryonsteroids_first_theme_registry_do_alter($registry, $base_themes, $theme, $user_functions, $prefixes);
}

/**
 * Alter the registry - first part of the workflow.
 *
 * @param array[] $registry
 * @param object[] $base_themes
 * @param object $theme
 * @param string[] $user_functions
 * @param string[] $prefixes
 */
function _registryonsteroids_first_theme_registry_do_alter(array &$registry, array $base_themes, $theme, array $user_functions, array $prefixes) {
  ksort($registry);

  $stubs = _registryonsteroids_build_stubs(
    $registry,
    $user_functions,
    $prefixes);

  ksort($stubs);

  $registry = array();
  foreach ($stubs as $hook => $stub) {
    $registry[$hook] = $stub->getRegistryEntry();
  }
}

/**
 * Build the theme registry stubs.
 *
 * @param array $registry
 * @param string[] $user_functions
 * @param string[] $prefixes
 *
 * @return \Drupal\registryonsteroids\ThemeHookStub[]
 */
function _registryonsteroids_build_stubs(array $registry, array $user_functions, array $prefixes) {
  $functions_by_hook_and_phasekey_and_weight = FunctionGroupUtil::groupFunctionsByHookAndPhasekeyAndWeight($user_functions, $prefixes);
  $functions_by_hook_and_phasekey_and_weight += array('*' => array());

  $declared_hooks = array_keys($registry);
  $declared_hooks = array_combine($declared_hooks, $declared_hooks);

  $declared_base_hooks = array();
  $declared_root_hooks = array();
  foreach ($registry as $hook => $info) {
    if (isset($info['base hook']) && $hook !== $info['base hook']) {
      $declared_base_hooks[$hook] = $info['base hook'];
    }
    else {
      $declared_root_hooks[$hook] = $hook;
    }
  }

  $discovered_hooks = array_keys($functions_by_hook_and_phasekey_and_weight);
  $discovered_hooks = array_combine($discovered_hooks, $discovered_hooks);
  $discovered_undeclared_hooks = array_diff_key($discovered_hooks, $declared_hooks);

  $sortme = array();
  foreach (array($declared_hooks, $discovered_undeclared_hooks) as $hooks) {
    foreach ($hooks as $hook) {
      $sortme[$hook . '__'] = $hook;
      $sortme[$hook . '__|'] = FALSE;
    }
  }

  ksort($sortme);

  /** @var \Drupal\registryonsteroids\ThemeHookStub[] $trail */
  $trail = array();

  /** @var \Drupal\registryonsteroids\ThemeHookStub[] $stubs */
  $stubs = array();
  /** @var \Drupal\registryonsteroids\ThemeHookStub|null $stub */
  $stub = NULL;
  $base_hooks = $declared_base_hooks;

  $factory = new ThemeHookStubFactory(
    $registry,
    $functions_by_hook_and_phasekey_and_weight);

  $base_hook = '*';
  foreach ($sortme as $hook_or_false) {
    if (FALSE === $hook_or_false) {
      $stub = array_pop($trail);
      continue;
    }

    $trail[] = $stub;
    $hook = $hook_or_false;

    if (isset($stubs[$hook])) {
      $stub = $stubs[$hook];
      continue;
    }

    if (isset($declared_root_hooks[$hook])) {
      // $hook has no parents.
      $stub = $factory->createStub($hook);
    }
    elseif (!isset($base_hooks[$hook]) || $base_hook === $base_hooks[$hook]) {
      // $hook has the existing $stub as a parent, if that exists.
      if (NULL === $stub) {
        // This is a discovered hook that is not an ancestor of a declared hook.
        continue;
      }
      $stub = $factory->createStub($hook, $stub);
    }
    else {
      // $hook has one base hook but no other parents.
      $base_hook = $base_hooks[$hook];
      if (isset($stubs[$base_hook])) {
        // Base hook was already calculated.
        $stub = $factory->createStub($hook, $stubs[$base_hook]);
      }
      elseif (isset($declared_root_hooks[$base_hook])) {
        // Base hook is a known root hook, we just haven't visited it yet.
        $base_stub = $factory->createStub($base_hook);
        $stub = $factory->createStub($hook, $base_stub);
      }
      else {
        // This is an invalid entry in theme registry.
        // Treat this as if it didn't have a base hook.
        $stub = $factory->createStub($hook);
      }
    }

    if (NULL !== $stub) {
      $stubs[$hook] = $stub;
    }
  }

  return $stubs;
}

/**
 * Callback for hook_theme_registry_alter()
 *
 * Registered to run after all other implemntations.
 *
 * @param array[] $registry
 *   Format: $[$theme_hook] = $info
 */
function _registryonsteroids_last_theme_registry_alter(array &$registry) {
  foreach ($registry as &$info) {
    if (isset($info['base hook'])) {
      $base_hook = $info['base hook'];
      if (!isset($registry[$base_hook])) {
        // @todo Log this.
        continue;
      }
      $base_hook_info = $registry[$base_hook];
      foreach (['preprocess functions', 'process functions'] as $phase_key) {
        $info[$phase_key] = isset($base_hook_info[$phase_key])
          ? $base_hook_info[$phase_key]
          : [];
      }

      unset($info['base hook']);
    }
  }

  foreach ($registry as &$info) {
    if (!isset($info['registryonsteroids replace'])) {
      continue;
    }

    foreach ($info['registryonsteroids replace'] as $phase_key => $replacements) {
      if (empty($info[$phase_key])) {
        continue;
      }
      foreach ($info[$phase_key] as $i => $function) {
        if (isset($replacements[$function])) {
          $info[$phase_key][$i] = $replacements[$function];
        }
      }
    }

    unset($info['registryonsteroids replace']);
  }

  foreach (FunctionGroupUtil::PHASES as $phase_key => $phase) {
    foreach ($registry as &$info) {
      if (!isset($info[$phase_key])) {
        continue;
      }
      $info[$phase_key] = preg_grep('/^@/', $info[$phase_key], PREG_GREP_INVERT);
    }
  }

  unset($registry['*']);
}

/**
 * Compile a list of prefixes.
 *
 * The order of this is very important.
 *
 * @param object[] $base_themes
 *   The array of base themes.
 * @param object $theme
 *   The current theme.
 *
 * @see https://api.drupal.org/api/drupal/includes!theme.inc/function/theme/7.x
 *
 * @return string[][]
 *   The prefixes.
 *   Format: $[$prefix_type][$prefix] = $prefix
 */
function _registryonsteroids_theme_make_prefixes(array $base_themes, $theme) {
  return array(
    'template' => array(
      'template' => 'template',
    ),
    'module' => module_list(),
    'theme_engine' => array(
      $theme->engine => $theme->engine,
    ),
    'base_theme' => array_combine(
      array_keys($base_themes),
      array_keys($base_themes)
    ),
    'theme' => array(
      $theme->name => $theme->name,
    ),
  );
}

/**
 * Group functions by hook and phase, with inheritance.
 *
 * @param string[] $user_functions
 * @param string[] $prefixes
 *   A whitelist of prefixes (module names, themes, etc).
 *
 * @return string[][][]
 *   Format: $[$hook][$phase_key][] = $function
 *   E.g. $['block']['preprocess'][] = 'system_preprocess_block'.
 */
function _registryonsteroids_group_functions_by_hook_and_phasekey_with_inheritance(array $user_functions, array $prefixes) {
  $functions_by_hook_and_phasekey_and_weight = FunctionGroupUtil::groupFunctionsByHookAndPhasekeyAndWeight($user_functions, $prefixes);

  $functions_by_hook_and_phasekey_and_weight_extended = $functions_by_hook_and_phasekey_and_weight;
  foreach ($functions_by_hook_and_phasekey_and_weight as $hook => $functions_by_phasekey) {
    $functions_by_hook_and_phasekey_and_weight_extended[$hook . '__'] = TRUE;
    $functions_by_hook_and_phasekey_and_weight_extended[$hook . '__|'] = FALSE;
  }

  ksort($functions_by_hook_and_phasekey_and_weight_extended);

  $keys = array_keys($functions_by_hook_and_phasekey_and_weight_extended);
  $keymap = array_flip($keys);
  $skipmap = array();
  foreach ($keys as $i => $key) {
    $entry = $functions_by_hook_and_phasekey_and_weight_extended[$key];
    if (TRUE === $entry || FALSE === $entry) {
      $skipmap[$i] = TRUE;
    }
  }

  $functionss_by_hook_and_phasekey_and_weight_with_inheritance = array();
  foreach ($keys as $i => $key) {
    if (TRUE !== $functions_by_hook_and_phasekey_and_weight_extended[$key]) {
      continue;
    }
    $end_key = $key . '|';
    $i_end = $keymap[$end_key];
    $parent_hook = $keys[$i - 1];
    $parent_hook_functions_by_phasekey_and_weight = $functions_by_hook_and_phasekey_and_weight_extended[$parent_hook];

    for ($j = $i - 1; $j < $i_end; ++$j) {
      if (isset($skipmap[$j])) {
        continue;
      }
      $hook_j = $keys[$j];
      foreach ($parent_hook_functions_by_phasekey_and_weight as $phase_key => $functions_by_weight) {
        foreach ($functions_by_weight as $weight => $function) {
          $functionss_by_hook_and_phasekey_and_weight_with_inheritance[$hook_j][$phase_key][$weight][] = $function;
        }
      }
    }
  }

  $functionss_by_hook_and_phasekey_with_inheritance = array();
  foreach ($functionss_by_hook_and_phasekey_and_weight_with_inheritance as $hook => $functionss_by_phasekey_and_weight) {
    foreach ($functionss_by_phasekey_and_weight as $phase_key => $functionss_by_weight) {
      ksort($functionss_by_weight);
      $functionss_by_hook_and_phasekey_with_inheritance[$hook][$phase_key] = array_merge(...$functionss_by_weight);
    }
  }

  return $functionss_by_hook_and_phasekey_with_inheritance;
}
